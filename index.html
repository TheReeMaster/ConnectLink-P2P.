That's a great next step! Adding a username makes your P2P app feel much more personalized and like a real social platform.

Since the entire application is run through a single HTML file without a central server or database, the username must be handled locally in the user's browser storage. This means the user sets their name once, and the app remembers it.

Here is the updated code for DataChain (index.html), which includes:

A Username Input and Storage using the browser's localStorage.

The ability for every post (text or image) to display the set Username instead of just the long Peer ID.

âœ¨ DataChain: P2P Social App with Usernames (index.html)
Save this entire block as your new index.html file.

HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataChain - P2P Social with Usernames</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* General Styles */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; padding: 25px; background-color: #f0f2f5; color: #1c1e21; }
        h1 { color: #5B2C6F; text-align: center; border-bottom: 3px solid #5B2C6F; padding-bottom: 15px; margin-bottom: 20px; font-weight: 700; }
        .info-box { background: #e7f3ff; border: 1px solid #1877f2; padding: 15px; margin-bottom: 25px; border-radius: 8px; font-size: 0.9em; }

        /* Identity and Connection */
        #my-id-container { text-align: center; margin-bottom: 30px; }
        #my-peer-id { font-size: 1.4em; font-weight: bold; color: #D50000; padding: 5px 10px; background: #fff; border-radius: 4px; display: inline-block; word-break: break-all; }
        #connection-area { display: flex; justify-content: center; margin-bottom: 20px; }
        #connection-area input, #connection-area button { padding: 10px; border-radius: 5px; border: 1px solid #ccc; margin-right: 10px; }
        #connection-area input { flex-grow: 1; max-width: 300px; }
        #connection-area button { background-color: #4CAF50; color: white; border: none; cursor: pointer; font-weight: bold; }
        #connection-area button:hover { background-color: #45a049; }
        #connected-count { margin-left: 20px; align-self: center; font-weight: 600; color: #333; }
        
        /* Username Specific Section */
        #username-section { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); margin-bottom: 20px; text-align: center;}
        #username-input { padding: 8px; margin: 0 10px; border-radius: 4px; border: 1px solid #ccc; width: 200px; }
        #username-display { font-weight: bold; color: #5B2C6F; }
        #save-username-button { background-color: #1877f2; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; }

        /* Posting Area */
        .post-box { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); margin-bottom: 30px; }
        #message-input { width: 100%; min-height: 70px; padding: 10px; box-sizing: border-box; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; resize: vertical; }
        #send-button { background-color: #8E44AD; }
        #send-button:hover { background-color: #6C3483; }

        /* File Input */
        #file-input-container { display: flex; align-items: center; margin-top: 15px; padding: 10px; border: 1px dashed #ccc; border-radius: 5px; background: #f9f9f9; }
        #file-input { display: none; }
        .file-label { background-color: #1877f2; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 15px; font-weight: bold; }
        .file-label:hover { background-color: #165be8; }

        /* Feed Display */
        #messages { list-style-type: none; padding: 0; }
        .message-item { background-color: #fff; padding: 15px; margin-bottom: 15px; border-left: 5px solid #8E44AD; border-radius: 8px; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }
        .message-sender { font-weight: bold; color: #333; font-size: 1.1em; margin-bottom: 8px; }
        .message-time { font-size: 0.8em; color: #777; float: right; }
        
        /* Image Specific Styles */
        .message-image { max-width: 100%; height: auto; border-radius: 6px; margin-top: 10px; border: 1px solid #eee; }
    </style>
</head>
<body>

    <h1>DataChain P2P Feed ðŸ”—</h1>
    <div class="info-box">
        Set your username below! Posts and images are transmitted directly between connected peers. Your username is saved locally in your browser.
    </div>

    <div id="username-section">
        <label for="username-input">Set Your Username:</label>
        <input type="text" id="username-input" placeholder="e.g., ChainMaster" maxlength="20">
        <button id="save-username-button" onclick="saveUsername()">Save</button>
        <p>Current User: <span id="username-display"></span></p>
    </div>

    <div id="my-id-container">
        Your P2P ID: <strong id="my-peer-id">...Generating...</strong>
    </div>

    <div id="connection-area">
        <input type="text" id="target-id" placeholder="Enter Peer ID to Connect">
        <button onclick="connectToPeer()">Connect</button>
        <div id="connected-count">Connected Peers: 0</div>
    </div>

    <hr>
    
    <div class="post-box">
        <h2>Share a Spark (Text or Picture)</h2>
        <textarea id="message-input" placeholder="Type your text spark here..." maxlength="280"></textarea>
        
        <div id="file-input-container">
            <label for="file-input" class="file-label">Select Picture</label>
            <input type="file" id="file-input" accept="image/*">
            <span id="file-status">No file selected.</span>
        </div>
        
        <button id="send-button" onclick="sendMessage()">Send Spark</button>
    </div>

    <h2>Received Sparks</h2>
    <ul id="messages"></ul>

<script>
    let peer; 
    let connections = {};
    let file = null;
    let imageChunks = {}; 
    const PEER_SERVER_HOST = '0.peerjs.com';
    const CHUNK_SIZE = 16 * 1024;
    
    // --- USERNAME LOGIC ---
    let USERNAME = localStorage.getItem('datachain_username') || 'Anonymous';

    function updateUsernameDisplay() {
        document.getElementById('username-display').innerText = USERNAME;
    }

    function saveUsername() {
        const input = document.getElementById('username-input');
        const newName = input.value.trim();
        if (newName) {
            USERNAME = newName;
            localStorage.setItem('datachain_username', newName);
            updateUsernameDisplay();
            alert(`Username saved as: ${newName}`);
        } else {
            alert("Please enter a valid username.");
        }
    }
    
    // --- UTILITIES ---
    function updateConnectedCount() {
        document.getElementById('connected-count').innerText = `Connected Peers: ${Object.keys(connections).length}`;
    }
    
    document.getElementById('file-input').addEventListener('change', (e) => {
        file = e.target.files[0];
        const statusEl = document.getElementById('file-status');
        if (file) {
            statusEl.innerText = `${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB) selected.`;
        } else {
            statusEl.innerText = 'No file selected.';
        }
    });

    function displayMessage(senderName, content, imageDataUrl = null) {
        const messagesUl = document.getElementById('messages');
        const li = document.createElement('li');
        li.className = 'message-item';
        
        const timestamp = new Date().toLocaleTimeString();
        
        let contentHtml = `<div class="message-sender">${senderName} <span class="message-time">${timestamp}</span></div>`;

        if (imageDataUrl) {
            contentHtml += `<img src="${imageDataUrl}" class="message-image" alt="P2P Image">`;
        }
        if (content) {
            contentHtml += `<div class="message-content">${content}</div>`;
        }
        
        li.innerHTML = contentHtml;
        messagesUl.prepend(li);
    }

    // --- P2P CONNECTION LOGIC ---

    function initializePeer() {
        peer = new Peer({ host: PEER_SERVER_HOST, secure: true, port: 443 });

        peer.on('open', (id) => {
            document.getElementById('my-peer-id').innerText = id;
            document.getElementById('message-input').disabled = false;
            document.getElementById('send-button').disabled = false;
            peer.on('connection', handleIncomingConnection);
        });
        peer.on('error', (err) => {
            console.error('PeerJS Error:', err);
            document.getElementById('my-peer-id').innerText = 'ERROR: Check console.';
        });
    }
    
    function connectToPeer() {
        const targetId = document.getElementById('target-id').value.trim();
        if (!targetId || targetId === peer.id) return alert("Please enter a valid, different Peer ID.");
        if (connections[targetId] && connections[targetId].open) return alert("Already connected to this peer!");

        const conn = peer.connect(targetId, {
            metadata: { username: USERNAME } // Pass your username when initiating the connection
        });
        
        conn.on('open', () => {
            connections[targetId] = conn; 
            setupConnectionListeners(conn);
            alert(`Successfully connected to peer: ${targetId}!`);
            updateConnectedCount();
        });
        conn.on('error', (err) => console.error(`Connection failed for ${targetId}:`, err));
    }

    function handleIncomingConnection(conn) {
        conn.on('open', () => {
            if (!connections[conn.peer] || !connections[conn.peer].open) {
                connections[conn.peer] = conn;
                setupConnectionListeners(conn);
                
                // Store the received peer's username
                conn.username = conn.metadata.username || 'Anonymous';

                alert(`New peer connected: ${conn.username} (${conn.peer})`);
                updateConnectedCount();
            }
        });
    }

    function setupConnectionListeners(conn) {
        // Store the username on the connection object for easier access
        conn.username = conn.metadata ? conn.metadata.username : conn.username || 'Anonymous';

        conn.on('data', (data) => {
            const senderName = data.senderName || conn.username;

            if (data.type === 'message') {
                displayMessage(senderName, data.content);
            } else if (data.type === 'image_chunk') {
                handleIncomingImageChunk(data, senderName);
            } else if (data.type === 'image_start') {
                imageChunks[data.id] = { 
                    chunks: [], 
                    count: data.count, 
                    mime: data.mime,
                    senderName: senderName, // Use the stored name
                    senderId: conn.peer
                };
            }
        });
        
        conn.on('close', () => {
            delete connections[conn.peer];
            displayMessage('SYSTEM', `Peer ${conn.username || conn.peer} disconnected.`);
            updateConnectedCount();
        });
    }
    
    // --- IMAGE CHUNKING AND REASSEMBLY ---
    
    function handleIncomingImageChunk(chunkData, senderName) {
        const imgId = chunkData.id;
        const storage = imageChunks[imgId];

        if (!storage) return;

        storage.chunks[chunkData.index] = chunkData.data;
        
        if (storage.chunks.filter(c => c).length === storage.count) {
            const base64String = storage.chunks.join('');
            const dataUrl = `data:${storage.mime};base64,${base64String}`;
            
            displayMessage(senderName, chunkData.content, dataUrl);
            
            delete imageChunks[imgId];
        }
    }

    // --- SENDING LOGIC ---
    
    async function sendMessage() {
        const content = document.getElementById('message-input').value.trim();
        const imgFile = file;

        if (!content && !imgFile) {
            alert("Please enter a message or select a picture.");
            return;
        }
        
        let sentCount = 0;

        if (imgFile) {
            sentCount = await sendFileInChunks(imgFile, content);
        } else {
            const messageData = { type: 'message', sender: peer.id, senderName: USERNAME, content: content };
            sentCount = sendDataToPeers(messageData);
        }
        
        if (sentCount > 0) {
            const imageDataUrl = imgFile ? URL.createObjectURL(imgFile) : null;
            displayMessage('YOU', content, imageDataUrl);
            
            document.getElementById('message-input').value = '';
            document.getElementById('file-input').value = '';
            document.getElementById('file-status').innerText = 'No file selected.';
            file = null;
        } else {
            alert("No open connections found! Please connect to a peer first.");
        }
    }
    
    function sendDataToPeers(data) {
        let count = 0;
        for (const peerId in connections) {
            const conn = connections[peerId];
            if (conn && conn.open) { 
                conn.send(data);
                count++;
            }
        }
        return count;
    }

    function sendFileInChunks(imgFile, content) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
                const base64Data = evt.target.result.split(',')[1];
                const totalChunks = Math.ceil(base64Data.length / CHUNK_SIZE);
                const imgId = peer.id + Date.now();
                let sentCount = 0;

                const startData = {
                    type: 'image_start',
                    id: imgId,
                    count: totalChunks,
                    mime: imgFile.type,
                    senderName: USERNAME, // Include username in start message
                };
                sentCount = sendDataToPeers(startData);
                if (sentCount === 0) return resolve(0);

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min((i + 1) * CHUNK_SIZE, base64Data.length);
                    
                    const chunkData = {
                        type: 'image_chunk',
                        id: imgId,
                        index: i,
                        count: totalChunks,
                        data: base64Data.substring(start, end),
                        // Only include senderName/content for the final chunk for efficiency
                        senderName: (i === totalChunks - 1) ? USERNAME : null, 
                        content: (i === totalChunks - 1) ? content : null 
                    };
                    sendDataToPeers(chunkData);
                }
                
                resolve(sentCount);
            };
            reader.readAsDataURL(imgFile);
        });
    }

    // --- INITIALIZATION ---
    updateUsernameDisplay();
    initializePeer();
</script>

</body>
</html>
